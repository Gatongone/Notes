# 设计模式
<details>
  <summary><font size= 4>单例模式</font></summary>
  <pre>

  </pre>
</details>

<details>
  <summary><font size= 4>工厂模式</font></summary>
  <pre>
  
  <font face="verdana" size =4 color = #9370DB>简单工厂(Simple Fatory Pattern):</font>

   ![SampleFatory](https://raw.githubusercontent.com/Gatongone/ImageContainer/main/UML/Factory.png)


    结构为：
        -Product 抽象产品类（可以是接口）：封装了产品的抽象方法
        -ProductA、B 具体产品类：实现了父类的抽象方法（接口），是简单工厂创建的目标，是抽象产品的实例
        -SimpleFactory 工厂：负责创建所有产品的内部逻辑，可以被外界直接调用，创建所需的对象
    
    缺点：
        若产品类增加，则需要增加工厂switch的判断破坏了开闭原则（允许新增类来扩展功能，不允许被修改原类代码）


```c#

    public abstract class Product//抽象产品类
    {
        public abstract string getName();
    }
    public class ProductA:Product//具体产品B
    {
        private string name{ get; set; }
        public override string getName()
        {
            return this.name;
        }
    }
    public class ProductB:Product//具体产品A
    {
        private string name{ get; set; }
        public override string getName()
        {
            return this.name;
        }
    } 
    public  class SimpleFactory//工厂类
    {
        public Product createProduct(string name)
        {
            switch (name)
            {
                case "A":
                        ProductA A = new ProductA();
                        System.Console.WriteLine("产品A被创建！");return A;
                        break;
                case "B":
                        ProductB B = new ProductB();
                        System.Console.WriteLine("产品B被创建！");return B; 
                        break;
                default:break;
            }
            return null;
        }
    }
    public class MainTest//测试类
    {
        public static void Main(string[] args)
        {
            SimpleFactory factory = new SimpleFactory();
            Product A = fatory.createProduct("A");
            Product B = fatory.createProduct("B");
        }
```

</pre>
  <pre>
  <font face="verdana" size =4 color = #9370DB>工厂方法模式(Factory Method):

  </font>

   ![Factory Method](https://raw.githubusercontent.com/Gatongone/ImageContainer/main/UML/Factory%20Method.png)

    结构为：
        -Product 抽象产品类（可以是接口）：封装了产品的抽象方法
        -ProductA、B 具体产品类：实现了父类的抽象方法（接口），是简单工厂创建的目标，是抽象产品的实例
        -FactoryA、B 工厂：负责创建某一类产品，可以被外界直接调用，创建所需的对象

    若产品类增加，则只需要增加工厂，这符合了开闭原则，但同时会使代码量和逻辑变得繁琐    

```c#
    public abstract class Product//产品抽象类
    {
        public abstract string getName();
    }
    public abstract class abstructFactory//工厂抽象类
    {
        public abstract Product createProduct(string name);
    }
    public class ProductA:ProductB//具体产品A
    {
        private string name{ get; set; }
        public ProductA(string name)
        {
            this.name =name;;
        }
        public override string getName()
        {
            return this.name;
        }
    }
    public class ProductB:Product//具体产品B
    {
        private string name{ get; set; }
        public ProductB(string name)
        {
            this.name =name;;
        }
        public override string getName()
        {
            return this.name;
        }
    } 
    public class FactoryA:abstructFactory//工厂A，负责创建产品A
    {
        public override Product createProduct(string name)
        {
            System.Console.WriteLine($"产品{name}被工厂A创建!");
            return new ProductA(name);
        }
    }
    public class FactoryB:abstructFactory//工厂B，负责创建产品B
    {
        public override Product createProduct(string name)
        {
            System.Console.WriteLine($"产品{name}被工厂B创建!");            
            return new ProductB(name);
        }
    }
    public class MainTest//测试类
    {
        public static void Main(string[] args)
        {
            FactoryA factoryA = new FactoryA();
            FactoryB factoryB = new FactoryB();
            Product A = factoryA.createProduct("A");
            Product B = factoryB.createProduct("B");
        }
    }
```
   </pre>
   <pre>
<font face="verdana" size =4 color = #9370DB>抽象工厂模式(Abstract Factory):

</font>

   ![abstructFactory](https://raw.githubusercontent.com/Gatongone/ImageContainer/main/UML/abstructFactory.png)

    结构为：
        -Product 抽象产品基类（可以是接口）：封装了产品的抽象方法
        -Phone、Shoes 抽象产品子类：继承了产品基类，是某一类产品的大类
        -Iphone、Huawei、Nike、Adidas：具体产品类：实现了父类的抽象方法（接口），是简单工厂创建的目标，是抽象产品的实例
        -FactoryA、B 工厂：负责创建某几个大类的产品，可以被外界直接调用，创建所需的对象

    在工厂方法模式的基础上新增一类产品，使得工厂可以生成多种类型的产品，此时应注意工厂类对产品大类的筛选应符合开闭原则，可以用泛型或产品基类的方法实现

```c#
    public abstract class Product//产品抽象类
    {
    }
    public abstract class Phone : Product//手机抽象类,继承了产品类
    {
    }
    public abstract class Shoes : Product//鞋抽象类，继承了产品类
    {
    }
    public abstract class abstructFactory//工厂抽象类
    {
        public abstract Product createProduct();
    }

    public class Huawei:Phone//华为手机，继承了手机抽象类
    {
        public Huawei()
        {
            System.Console.WriteLine("Huawei");
        }
    }
    public class Iphone:Phone//苹果手机，继承了手机抽象类
    {
        public Iphone()
        {
            System.Console.WriteLine("Iphone");
        }
    } 
    public class Adidas:Shoes//阿迪鞋，继承了鞋抽象类
    {
        public Adidas()
        {
           System.Console.WriteLine("Adidas");
        }
        
    }
    public class Nike:Shoes//耐克鞋，继承了鞋抽象类
    {
        public Nike()
        {
            System.Console.WriteLine("Nike");
        }
    }    
    public class FactoryA<T>:abstructFactory where T:Product,new()//A工厂，可以生产手机和鞋
    {
        public override T createProduct()
        {
            System.Console.Write("工厂A创建了");
            return new T();
        }
    }
    public class FactoryB<T>:abstructFactory where T:Product,new()//B工厂，可以生产手机和鞋
    {
        public override T createProduct()
        {
            System.Console.Write("工厂B创建了");
            return new T();
        }
    }
    public class MainTestB//测试类
    {
        public static void Main(string[] args)
        {
            FactoryA<Iphone> factoryA = new FactoryA<Iphone>();
            FactoryB<Nike> factoryB = new FactoryB<Nike>();
            Phone A = factoryA.createProduct();
            Shoes B = factoryB.createProduct();
        }
    }
```

   </pre>

</details>



<details>
  <summary><font size= 4>策略模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>观察者模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>适配器模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>访问者模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>状态模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>迭代器模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>模板方法模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>代理模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>命令模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>原型模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>中介者模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>生成器模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>备忘录模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>装饰器模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>责任链模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>享元模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>桥接模式</font></summary>
  <pre>



  </pre>
</details>

<details>
  <summary><font size= 4>组合模式</font></summary>
  <pre>



  </pre>
</details>
