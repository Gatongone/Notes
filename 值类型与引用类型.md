# C#中的值类型和引用类型

## 常见的值类型和引用类型

* ### 值类型：
    * 无符号类型：byte,ushort,uint,ulong
    * 有符号类型：sbyte,short,int,long
    * 浮点类型：float,double,decimal
    * 布尔类型：bool
    * 字符型：char
    * 枚举：enum
    * 结构体：struct
    * 指针：int*,float*,......

* ### 引用类型：
    * 类：class
    * 接口：interface
    * 数组：xxx\[\] 
    * 委托：delegate,Func<>,Action<>
    * 可空类型：int?,float?,......
    * 其他：string,DateTime......

</br>
</br>
</br>

## 值类型和引用类型的区别
* 值类型实例一般保存在线程栈中，因此不受GC的控制，缓解了托管堆中的压力。值类型的实例就是自己本身。值类型创建时，runtime会为其分配一个内存空间到栈上。
  
* 引用类型一定分配在托管堆中，在C#中受到GC的控制，以此过多的引用类型会导致GC的次数，以致于性能下降。引用类型被创建（new）时，runtime会创建两个内存空间，一个分配在栈上用于保存实例，一个分配在堆中用于保存指向实例的内存地址。
  
* ps：值类型不一定都是保存在线程栈中的
  如果值类型是方法内部创建的，则被保存在线程栈上；
  如果值类型是引用类型的成员变量，则跟随引用类型被存储在托管堆中。

</br>
</br>
</br>

## 值类型和引用类型的转换（装箱与拆箱）

* ### 装箱
    
    装箱就是将值类型转换成引用类型，过程为：
    
    1. 在托管堆中分配内存，容量为：实例字段 + 类型指针 + 同步块索引
    2. Copy字段到刚分配的堆内存中
    3. 返回堆中新分配对象的地址，该地址是指向值对象的引用
    ```C#
    int num = 5;
    object obj = num;//装箱
    ```
    ![img](https://raw.githubusercontent.com/Gatongone/ImageContainer/main/Others/%E8%A3%85%E7%AE%B1.jpg)

</br>
</br>   

* ### 拆箱
    拆箱就是将已装箱的值类型（装箱之后就是引用类型了）转换成值类型，过程为：

    1. 获取托管堆中属于值类型那部分字段的地址，
    2. 将引用对象中的值Copy到位于线程堆栈上的值类型实例中。 
    ```C#
    object obj = 5;
    int i = (int)obj;
    ```
    ![img](https://raw.githubusercontent.com/Gatongone/ImageContainer/main/Others/%E6%8B%86%E7%AE%B1.jpg)


</br>
</br>
</br>

## is和as:对类型的判断和转换
* ## as
    ```C#
        Object obj = new Object();
        Type type = obj as Type;//用强制转换的方法则需要try-catch保护，因为这是线程不安全的
    ```
    as操作符对于 **目标类型属于目标类型或者目标类型的派生类型** 才能转换成功，否则返回null；

    注意as操作符不能对值类型进行转换。

* ## is

    ```C#
        Object obj = 1;

        if (obj is int)
        {
            int value = (int) obj;
        }

        //或者
        int value = obj is int ? (int)obj : default(int);

        //对于非空类型转换成值类型
        int v;
        int? r = 5;
        v = r is int? ?  (int)r : 0;
    ````
    is关键字会对给定类型进行检测其是否兼容(对对象检测是否是is后面类型的类或派生类，因此这是安全的),并返回一个bool类型；

    注意is的左边不能是匿名方法(lambda表达式除外)。

